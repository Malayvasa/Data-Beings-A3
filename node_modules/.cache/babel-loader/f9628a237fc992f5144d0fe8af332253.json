{"ast":null,"code":"import React, { useState, useCallback, useEffect } from 'react';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n// fill out a couple protovis dependencies\n\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\n\n\nif (!pv) {\n  var pv = {\n    map: function (array, f) {\n      var o = {};\n      return f ? array.map(function (d, i) {\n        o.index = i;\n        return f.call(o, d);\n      }) : array.slice();\n    },\n    naturalOrder: function (a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function (array, f) {\n      var o = {};\n      return array.reduce(f ? function (p, d, i) {\n        o.index = i;\n        return p + f.call(o, d);\n      } : function (p, d) {\n        return p + d;\n      }, 0);\n    },\n    max: function (array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    }\n  };\n}\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\n\n\nvar MMCQ = function () {\n  // private constants\n  var sigbits = 5,\n      rshift = 8 - sigbits,\n      maxIterations = 1000,\n      fractByPopulations = 0.75; // get reduced-space color index for a pixel\n\n  function getColorIndex(r, g, b) {\n    return (r << 2 * sigbits) + (g << sigbits) + b;\n  } // Simple priority queue\n\n\n  function PQueue(comparator) {\n    var contents = [],\n        sorted = false;\n\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n\n    return {\n      push: function (o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function (index) {\n        if (!sorted) sort();\n        if (index === undefined) index = contents.length - 1;\n        return contents[index];\n      },\n      pop: function () {\n        if (!sorted) sort();\n        return contents.pop();\n      },\n      size: function () {\n        return contents.length;\n      },\n      map: function (f) {\n        return contents.map(f);\n      },\n      debug: function () {\n        if (!sorted) sort();\n        return contents;\n      }\n    };\n  } // 3d color space box\n\n\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n\n  VBox.prototype = {\n    volume: function (force) {\n      var vbox = this;\n\n      if (!vbox._volume || force) {\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\n      }\n\n      return vbox._volume;\n    },\n    count: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._count_set || force) {\n        var npix = 0,\n            i,\n            j,\n            k,\n            index;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n\n      return vbox._count;\n    },\n    copy: function () {\n      var vbox = this;\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n    },\n    avg: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._avg || force) {\n        var ntot = 0,\n            mult = 1 << 8 - sigbits,\n            rsum = 0,\n            gsum = 0,\n            bsum = 0,\n            hval,\n            i,\n            j,\n            k,\n            histoindex;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //console.log('empty box');\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n        }\n      }\n\n      return vbox._avg;\n    },\n    contains: function (pixel) {\n      var vbox = this,\n          rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\n    }\n  }; // Color map\n\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n    });\n  }\n\n  CMap.prototype = {\n    push: function (vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg()\n      });\n    },\n    palette: function () {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function () {\n      return this.vboxes.size();\n    },\n    map: function (color) {\n      var vboxes = this.vboxes;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n\n      return this.nearest(color);\n    },\n    nearest: function (color) {\n      var vboxes = this.vboxes,\n          d1,\n          d2,\n          pColor;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n\n      return pColor;\n    },\n    forcebw: function () {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      }); // force darkest color to black if everything < 5\n\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) vboxes[0].color = [0, 0, 0]; // force lightest color to white if everything > 251\n\n      var idx = vboxes.length - 1,\n          highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) vboxes[idx].color = [255, 255, 255];\n    }\n  }; // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n\n  function getHisto(pixels) {\n    var histosize = 1 << 3 * sigbits,\n        histo = new Array(histosize),\n        index,\n        rval,\n        gval,\n        bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n        rmax = 0,\n        gmin = 1000000,\n        gmax = 0,\n        bmin = 1000000,\n        bmax = 0,\n        rval,\n        gval,\n        bval; // find min/max\n\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) rmin = rval;else if (rval > rmax) rmax = rval;\n      if (gval < gmin) gmin = gval;else if (gval > gmax) gmax = gval;\n      if (bval < bmin) bmin = bval;else if (bval > bmax) bmax = bval;\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) return;\n    var rw = vbox.r2 - vbox.r1 + 1,\n        gw = vbox.g2 - vbox.g1 + 1,\n        bw = vbox.b2 - vbox.b1 + 1,\n        maxw = pv.max([rw, gw, bw]); // only one pixel, no split\n\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n\n\n    var total = 0,\n        partialsum = [],\n        lookaheadsum = [],\n        i,\n        j,\n        k,\n        sum,\n        index;\n\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n\n    function doCut(color) {\n      var dim1 = color + '1',\n          dim2 = color + '2',\n          left,\n          right,\n          vbox1,\n          vbox2,\n          d2,\n          count2 = 0;\n\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2)); // avoid 0-count boxes\n\n          while (!partialsum[d2]) d2++;\n\n          count2 = lookaheadsum[d2];\n\n          while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2]; // set dimensions\n\n\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1; // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\n          return [vbox1, vbox2];\n        }\n      }\n    } // determine the cut planes\n\n\n    return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\n  }\n\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      // console.log('wrong number of maxcolors');\n      return false;\n    } // XXX: check color content and convert to grayscale if insufficient\n\n\n    var histo = getHisto(pixels);\n    histo.forEach(function () {}); // get the beginning vbox from the colors\n\n    var vbox = vboxFromPixels(pixels, histo),\n        pq = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count(), b.count());\n    });\n    pq.push(vbox); // inner function to do the iteration\n\n    function iter(lh, target) {\n      var ncolors = 1,\n          niters = 0,\n          vbox;\n\n      while (niters < maxIterations) {\n        vbox = lh.pop();\n\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        } // do the cut\n\n\n        var vboxes = medianCutApply(histo, vbox),\n            vbox1 = vboxes[0],\n            vbox2 = vboxes[1];\n\n        if (!vbox1) {\n          // console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n\n        lh.push(vbox1);\n\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n\n        if (ncolors >= target) return;\n\n        if (niters++ > maxIterations) {\n          // console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n      }\n    } // first set of colors, sorted by population\n\n\n    iter(pq, fractByPopulations * maxcolors); // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n    // Re-sort by the product of pixel occupancy times the size in color space.\n\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    } // next set - generate the median cuts using the (npix * vol) sorting.\n\n\n    iter(pq2, maxcolors - pq2.size()); // calculate the actual colors\n\n    var cmap = new CMap();\n\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n\n    return cmap;\n  }\n\n  return {\n    quantize: quantize\n  };\n}();\n\nvar quantize = MMCQ.quantize;\nvar CHANNELS = 4;\nvar FORMATS = {\n  rgb: 'rgb',\n  hex: 'hex'\n};\nvar DEFAULT_SETTINGS = {\n  colors: 5,\n  cors: false,\n  windowSize: 50,\n  format: FORMATS.hex\n};\n\nfunction useImageColor(src) {\n  var _settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var settings = _objectSpread2({}, DEFAULT_SETTINGS, {}, _settings);\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      colors = _useState2[0],\n      setColors = _useState2[1];\n\n  var chunk = useCallback(function (original) {\n    var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n    var data = [];\n\n    for (var i = 0; i < original.length; i += chunkSize * settings.windowSize) {\n      data.push(original.slice(i, i + chunkSize));\n    }\n\n    return data;\n  }, [settings.windowSize]);\n  var mapToHex = useCallback(function (values) {\n    return \"#\".concat(values.map(function (i) {\n      var h = i.toString('16');\n      return h.length < 2 ? \"0\".concat(h) : h;\n    }).join(''));\n  }, []);\n\n  if (!FORMATS[settings.format]) {\n    throw new Error('Invalid output format');\n  }\n\n  useEffect(function () {\n    var canvas = document.createElement('canvas');\n    var img = document.createElement('img');\n    var context = canvas.getContext('2d');\n\n    if (settings.cors) {\n      img.setAttribute('crossOrigin', '');\n    }\n\n    img.onload = function () {\n      canvas.width = img.naturalWidth;\n      canvas.height = img.naturalHeight;\n      context.drawImage(img, 0, 0);\n\n      var _context$getImageData = context.getImageData(0, 0, img.naturalWidth, img.naturalHeight),\n          data = _context$getImageData.data;\n\n      var colorMap = quantize(chunk(data, CHANNELS), settings.colors);\n      var pallete = colorMap.palette();\n      setColors(settings.format === FORMATS.rgb ? pallete : pallete.map(mapToHex));\n    };\n\n    img.src = src;\n  }, [src, settings.cors, settings.colors, settings.format, chunk, mapToHex]);\n  return {\n    colors: colors\n  };\n}\n\nvar wrapperDiv = {\n  width: '100%',\n  position: 'relative'\n};\nvar bg = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: '100%',\n  height: '100%',\n  position: 'absolute'\n};\nvar imageStyle = {\n  width: '100%',\n  height: 'auto',\n  display: 'block',\n  position: 'relative'\n};\n\nfunction ImageComponent(_ref) {\n  var src = _ref.src,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? {} : _ref$style,\n      thumbnail = _ref.thumbnail,\n      _ref$wrapperStyle = _ref.wrapperStyle,\n      wrapperStyle = _ref$wrapperStyle === void 0 ? {} : _ref$wrapperStyle,\n      _ref$wrapperClassName = _ref.wrapperClassName,\n      wrapperClassName = _ref$wrapperClassName === void 0 ? '' : _ref$wrapperClassName,\n      props = _objectWithoutProperties(_ref, [\"src\", \"style\", \"thumbnail\", \"wrapperStyle\", \"wrapperClassName\"]);\n\n  var _useImageColor = useImageColor(thumbnail, {\n    cors: true\n  }),\n      colors = _useImageColor.colors;\n\n  return React.createElement(\"div\", {\n    className: wrapperClassName,\n    style: _objectSpread2({}, wrapperDiv, {}, wrapperStyle)\n  }, colors && React.createElement(\"div\", {\n    style: _objectSpread2({}, bg, {\n      backgroundColor: colors[0]\n    })\n  }), React.createElement(\"img\", _extends({\n    style: _objectSpread2({}, imageStyle, {}, style),\n    src: src\n  }, props)));\n}\n\nexport default useImageColor;\nexport { ImageComponent as Image };","map":{"version":3,"sources":["../node_modules/quantize/quantize.js","../src/useImageColor.js","../src/components/Image.jsx"],"names":["CHANNELS","FORMATS","rgb","hex","DEFAULT_SETTINGS","colors","cors","windowSize","format","_settings","settings","setColors","useState","chunk","useCallback","chunkSize","data","i","original","mapToHex","h","useEffect","canvas","document","img","context","colorMap","quantize","pallete","wrapperDiv","width","position","bg","top","left","right","bottom","height","imageStyle","display","src","style","thumbnail","wrapperStyle","wrapperClassName","props","useImageColor","backgroundColor"],"mappings":"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","sourcesContent":["/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k, index;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nmodule.exports = MMCQ.quantize\n","import quantize from 'quantize';\nimport { useEffect, useState, useCallback } from 'react';\n\nconst CHANNELS = 4;\nconst FORMATS = { rgb: 'rgb', hex: 'hex' };\nconst DEFAULT_SETTINGS = {\n  colors: 5,\n  cors: false,\n  windowSize: 50,\n  format: FORMATS.hex,\n};\n\nexport default function useImageColor(src, _settings = {}) {\n  const settings = { ...DEFAULT_SETTINGS, ..._settings };\n  const [colors, setColors] = useState();\n\n  const chunk = useCallback((original, chunkSize = 4) => {\n    const data = [];\n\n    for (let i = 0; i < original.length; i += chunkSize * settings.windowSize) {\n      data.push(original.slice(i, i + chunkSize));\n    }\n\n    return data;\n  }, [settings.windowSize]);\n\n  const mapToHex = useCallback(\n    (values) => `#${values.map((i) => {\n      const h = i.toString('16');\n      return h.length < 2 ? `0${h}` : h;\n    }).join('')}`,\n    [],\n  );\n\n  if (!FORMATS[settings.format]) {\n    throw new Error('Invalid output format');\n  }\n\n  useEffect(() => {\n    const canvas = document.createElement('canvas');\n    const img = document.createElement('img');\n\n    const context = canvas.getContext('2d');\n\n    if (settings.cors) {\n      img.setAttribute('crossOrigin', '');\n    }\n\n    img.onload = () => {\n      canvas.width = img.naturalWidth;\n      canvas.height = img.naturalHeight;\n      context.drawImage(img, 0, 0);\n      const { data } = context.getImageData(0, 0, img.naturalWidth, img.naturalHeight);\n      const colorMap = quantize(chunk(data, CHANNELS), settings.colors);\n      const pallete = colorMap.palette();\n      setColors(settings.format === FORMATS.rgb ? pallete : pallete.map(mapToHex));\n    };\n\n    img.src = src;\n  }, [src, settings.cors, settings.colors, settings.format, chunk, mapToHex]);\n\n  return { colors };\n}\n","import React from 'react';\nimport useImageColor from '../useImageColor';\n\nconst wrapperDiv = {\n  width: '100%',\n  position: 'relative',\n};\n\nconst bg = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: '100%',\n  height: '100%',\n  position: 'absolute',\n};\n\nconst imageStyle = {\n  width: '100%',\n  height: 'auto',\n  display: 'block',\n  position: 'relative',\n};\n\nexport default function ImageComponent({\n  src,\n  style = {},\n  thumbnail,\n  wrapperStyle = {},\n  wrapperClassName = '',\n  ...props\n}) {\n  const { colors } = useImageColor(thumbnail, { cors: true });\n  return (\n    <div className={wrapperClassName} style={{ ...wrapperDiv, ...wrapperStyle }}>\n      { colors && <div style={{ ...bg, backgroundColor: colors[0] }} /> }\n      { <img style={{ ...imageStyle, ...style }} src={src} {...props} /> }\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}